\documentclass{exam}

\usepackage{indentfirst}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{color}
\usepackage{fancyvrb}
\usepackage{amsmath}
\usepackage{amssymb}

\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}

\lstset{ %
	backgroundcolor=\color{white},			% choose the background color
	basicstyle=\small\ttfamily,				% the size of the fonts that are used for the code
	breakatwhitespace=false,				% sets if automatic breaks should only happen at whitespace
	breaklines=true,						% sets automatic line breaking
	captionpos=b,							% sets the caption-position to bottom
	columns=fullflexible,
	commentstyle=\color{mygreen},			% comment style
	deletekeywords={...},					% if you want to delete keywords from the given language
	escapeinside={\%*}{*)},					% if you want to add LaTeX within your code
	extendedchars=true,						% lets you use non-ASCII characters
	frame=single,							% adds a frame around the code
	keepspaces=true,						% keeps spaces in text, useful for keeping indentation of code
	keywordstyle=\color{blue},				% keyword style
	language=Octave,						% the language of the code
	morekeywords={*,...},					% if you want to add more keywords to the set
	showspaces=false,						% show spaces everywhere adding particular underscores
	showstringspaces=false,					% underline spaces within strings only
	showtabs=false,							% show tabs within strings adding particular underscores
	stepnumber=1,							% the step between two line-numbers
	stringstyle=\color{mymauve},			% string literal style
	tabsize=2,								% sets default tabsize to 2 spaces
	title=\lstname							% show the filename of files included with \lstinputlisting
}

\newcommand{\octavescript}[2]{
	\lstinputlisting[caption=#2]{#1}
}

\newcommand{\MNLab}{Laborator\ \#7}
\newcommand{\MNLabTitle}{Calculul valorilor proprii şi vectorilor proprii prin metodele puterii. Metoda Householder}
\newcommand{\MNLabTitleHeader}{Valori și vectori proprii}
\newcommand{\MNAuthor}{Andrei STAN, Dumitru-Clementin Cercel, Alexandru Țifrea}

\renewcommand{\contentsname}{Cuprins}
\renewcommand{\figurename}{Figura}

\setlength{\parskip}{0.5\baselineskip}

\graphicspath{{./img/}}

\title{
	\textmd{\textbf{\MNLabTitle}}
	\author{}
        \date{}
}

\pagestyle{headandfoot}

\header{Metode Numerice}
{\MNLabTitleHeader}
{2025}
\footer{Facultatea de Automatică și Calculatoare}{}{Pagina \thepage\ din \numpages}

\begin{document}

\begin{coverpages}

	\maketitle
        \thispagestyle{empty}
	\tableofcontents

\end{coverpages}

\section{Obiective laborator}

În urma parcurgerii acestui laborator, studentul va fi capabil să:

\begin{itemize}
	\item utilizeze metoda puterii directe şi metoda puterii inverse pentru a determina valorile şi vectorii proprii ale unei matrice;
	\item aplice metoda Householder pentru a determina valorile şi vectorii proprii ale unei matrice;
	\item aplice proprietățile valorilor şi vectorilor proprii în rezolvarea unor probleme.
\end{itemize}


%----------------------------------------------------------------------------------------
%       TEORIE
%----------------------------------------------------------------------------------------

\section{Noțiuni teoretice}

Vom începe prin a prezenta conceptul de valoare proprie și vector propriu pentru o matrice pătrată
$A \in \mathbb{C}^{n\times n}$. Se numește \emph{valoare proprie} a lui $A$ orice număr complex
$\lambda \in \mathbb{C}$ pentru care există un vector nenul $x \in \mathbb{C}^{n}$ (\emph{vector propriu}), astfel încât
\[
	A x = \lambda x.
\]

Mulțimea tuturor valorilor proprii ale matricei $A$ se numește \emph{spectrul} matricei și se notează cu
\[
	\lambda(A) = \{ \lambda_1, \lambda_2, \ldots, \lambda_n\}.
\]
Două proprietăți importante ale valorilor proprii ale unei matrice $A\in\mathbb{C}^{n\times n}$ sunt:
\begin{itemize}
	\item \(\displaystyle \sum\limits_{i=1}^n \lambda_{i} = \mathrm{tr}(A)\), adică suma valorilor proprii este egală cu urma (suma diagonală) a matricei.
	\item \(\displaystyle \prod\limits_{i=1}^n \lambda_{i} = \det(A)\), adică produsul valorilor proprii este determinantul matricei.
\end{itemize}

Pentru a determina practic valorile proprii, se consideră polinomul caracteristic
\(\ p(\lambda) = \det(\lambda I_n - A)\),
iar valorile proprii sunt rădăcinile acestui polinom. Deși acest aspect este esențial din punct de vedere teoretic, în practică se apelează la metode numerice eficiente pentru a obține valorile și vectorii proprii, mai ales atunci când dimensiunea matricei este mare.

\subsection*{Matrici asemenea}

Două matrici \(A, B \in \mathbb{C}^{n \times n}\) se numesc \emph{asemenea} dacă există o matrice nesingulară \(T\) astfel încât
\[
	B = T^{-1} A \, T.
\]
Este ușor de arătat că această relație de asemănare implică faptul că \(A\) și \(B\) au același polinom caracteristic și, în consecință, aceleași valori proprii. Mai mult, vectorii proprii corespunzători se leagă între ei prin transformarea dată de \(T\). Practic, asemănarea este o transformare ce nu modifică spectrul matricei, ci doar \emph{reprezentarea} acesteia.

\subsection*{Forma Schur}

O aplicație importantă a ideii de asemănare este \emph{Forma Schur}. Teorema Schur afirmă că pentru orice matrice \(A \in \mathbb{C}^{n\times n}\) există o matrice unitară \(\widehat{Q}\) astfel încât
\[
	S = \widehat{Q}^{\,T} \,A\, \widehat{Q}
\]
este o matrice superior triunghiulară (în cazul complex). Această matrice \(S\) se numește \emph{forma Schur complexă} a matricei \(A\). În cazul real, există o matrice ortogonală \(Q\) pentru care
\[
	S = Q^T \, A \, Q
\]
este cvasi-triunghiulară superior (pe diagonală putem avea blocuri de dimensiune \(1 \times 1\) sau \(2 \times 2\)), această formă fiind numită \emph{forma Schur reală}. Blocurile \(2\times 2\) corespund perechilor de valori proprii complexe (conjugate).

\textbf{Demonstrație (schiță):} Pornind de la faptul că orice matrice complexă \(A\) are cel puțin o valoare proprie, se poate construi un vector propriu și forma o bază în care primul vector propriu apare simplu. Se aplică inductiv aceeași idee pentru submatricea rămasă, iar la fiecare pas se folosesc transformări unitare (în cazul complex) sau ortogonale (în cazul real). Prin construcție, forma finală devine (cvasi-)triunghiulară.

Forma Schur este utilă în multe algoritmi numerici pentru calculul valorilor proprii, deoarece odată ce matricea este adusă în formă Schur, valorile proprii apar direct pe diagonala sau în blocurile \(2\times 2\).

\subsection{Determinarea vectorilor şi valorilor proprii}

În continuare, vom descrie câteva metode numerice utilizate pentru a determina valorile şi vectorii proprii ai unei matrice.

\subsubsection{Metoda puterii directe}

Fie matricea $A \in \mathbb{R}^{n\times n}$, cu spectrul $\lambda(A) = \{\lambda_1,\lambda_2,\dots,\lambda_n\}$ și vectori proprii unitarizați $x_1,x_2,\dots,x_n$. Se presupune că
\[
	|\lambda_1| \ge |\lambda_2| \ge \dots \ge |\lambda_n|.
\]
Pentru un vector inițial $y \in \mathbb{R}^{n}$, cu normă euclidiană $1$, care are componentă nenulă pe direcția lui $x_1$, metoda puterii directe construiește șirul
\[
	y^{(k)} = \frac{A\,y^{(k-1)}}{\|A\,y^{(k-1)}\|_2}, \quad k \ge 1,
\]
pornind de la $y^{(0)} = y$. Simultan, se calculează
\[
	\lambda^{(k)} = (y^{(k)})^T A\,y^{(k)}.
\]
Se poate demonstra că $\lambda^{(k)}\to \lambda_1$ (valoarea proprie cu modul maxim), iar $y^{(k)}\to x_1$ (vectorul propriu asociat). Convergența apare pentru orice alegere inițială de $y$, atât timp cât proiecția pe $x_1$ nu este nulă.

\paragraph*{Forma Jordan}
\emph{Forma Jordan} reprezintă o structură canonică în care poate fi adusă o matrice, printr-o transformare de asemănare. În forma Jordan, matricea este bloc diagonală, unde fiecare bloc (numit \emph{bloc Jordan}) corespunde unei valori proprii și are pe diagonală exact acea valoare proprie, iar deasupra diagonalei pot apărea $1$-uri (în cazul în care avem o rădăcină cu multiplicitate mai mare și spațiul propriu asociat nu este suficient pentru o diagonalizare completă). În esență, forma Jordan arată cum se “compun” spațiile proprii și spațiile generalizate proprii ale unei matrice.

\subparagraph{Legătura metodei puterii directe cu Forma Jordan.}  
Pentru a înțelege de ce metoda puterii directe se focalizează pe valoarea proprie cu modul maxim, putem privi matricea $A$ în forma sa Jordan. Practic, dacă proiectăm vectorul inițial pe blocurile Jordan, componentele asociate valorilor proprii mai mici (în termeni de modul) vor deveni neglijabile pe măsură ce înmulțim în mod repetat cu $A$. Astfel, vectorul rezultat “se îndreaptă” către blocul Jordan dominant (valoarea proprie cu cel mai mare modul), iar direcția finală tinde să fie determinată de vectorul propriu asociat acelei valori proprii. Chiar și atunci când $A$ nu este diagonalizabilă în sens strict, interpretarea prin forma Jordan arată clar că iterațiile favorizează valoarea proprie dominantă, făcând din metoda puterii directe o alegere practică pentru găsirea acesteia.

\subsubsection{Metoda puterii inverse}

Metoda puterii inverse aplică ideea puterii directe la matricea $B = (A - \mu I)^{-1}$. Dacă $\mu$ se află în apropierea uneia dintre valorile proprii ale lui $A$, atunci valoarea proprie a lui $B$ cu modul cel mai mare (adică cea dominantă) corespunde acelei valori proprii a lui $A$. Concret, dacă $\mu \approx \lambda_j$, atunci $\lambda_j - \mu \approx 0$, iar inversul $(A - \mu I)^{-1}$ devine “mare” pe direcția asociată lui $\lambda_j$. 

\paragraph{Iterarea câtului Rayleigh.}  
O versiune mult mai eficientă a metodei puterii inverse o constituie \emph{iterarea câtului Rayleigh} (sau metoda puterii inverse cu deplasare variabilă). Pentru o aproximație curentă $x^{(k)}$ a vectorului propriu, se calculează valoarea:
\[
	\rho^{(k)} = \frac{(x^{(k)})^T A \, x^{(k)}}{(x^{(k)})^T x^{(k)}}.
\]
Această mărime, numită \emph{cât Rayleigh}, reprezintă o estimare a valorii proprii asociate lui $x^{(k)}$. Apoi, în pasul următor, se folosește $\mu = \rho^{(k)}$ drept noua deplasare. Cu alte cuvinte, la fiecare iterație:

\[
	(A - \rho^{(k)} I)\, z = x^{(k)}, 
\]
\[
	x^{(k+1)} = \frac{z}{\|z\|_2},
\]
\[
	\rho^{(k+1)} = \frac{(x^{(k+1)})^T A \, x^{(k+1)}}{(x^{(k+1)})^T x^{(k+1)}}.
\]

Repetând acest procedeu, vectorul și valoarea proprie estimate converg rapid spre vectorul și valoarea reală asociate lui $\lambda_j$. Această strategie este extrem de utilă atunci când avem deja un indiciu despre poziția unei valori proprii, întrucât viteza de convergență devine foarte mare după ce $\rho^{(k)}$ se apropie suficient de $\lambda_j$. În practică, iterarea câtului Rayleigh se folosește pe scară largă în algoritmi de diagonalizare numerică și este adesea componenta centrală în metode avansate de calculul valorilor proprii.


\subsubsection{Metoda deflației}

Metoda \emph{deflației} permite, după ce s-a găsit o valoare proprie și un vector propriu asociat, să se “reducă” problema la o submatrice pentru determinarea celorlalte valori proprii. O abordare simplă este \emph{deflația Wielandt}:

\begin{itemize}
	\item Se consideră că am aflat valoarea proprie dominantă $\lambda_1$ și vectorul propriu asociat $x_1$ (de pildă, prin metoda puterii directe).
	\item Se construiește matricea
	      \[
	      	B = (I_n - x_1\,y^T)\,A,
	      \]
	      unde $y \in \mathbb{R}^n$ se alege astfel încât $y^T x_1 = 1$. Se poate arăta că $B$ “blochează” componenta pe direcția $x_1$ și are valorile proprii
	      \(\{0, \lambda_2, \lambda_3, \dots,\lambda_n\}\).
	\item Apoi se elimină prima linie și prima coloană (corespunzătoare valorii proprii 0), obținându-se o submatrice care își păstrează celelalte valori proprii $\lambda_2,\ldots,\lambda_n$. Peste această submatrice, se aplică din nou o metodă (de exemplu, puterea directă) pentru a găsi următoarea valoare proprie dominantă.
\end{itemize}

\paragraph{Exemplu: Matricea Google (PageRank).}  
Matricea Google este un exemplu faimos de matrice stocastică, folosită în \emph{algoritmul PageRank}. Ideea de bază este că fiecare pagină web este un nod, iar legăturile (link-urile) către alte pagini definesc o probabilitate de \emph{tranziție} de la o pagină la alta. Pentru a rezolva probleme de tip “pagină izolată” sau sub-componente care nu influențează semnificativ restul rețelei, se folosesc tehnici de \emph{deflație}, prin care se separă anumite sub-blocuri ale matricei și se rezolvă problema pe blocuri mai mici.

\begin{itemize}
  \item \textbf{Cum se construiește Matricea Google?} Se consideră că avem $n$ pagini web, notate $P_1, P_2, \ldots, P_n$. Dacă pagina $P_i$ are link-uri către paginile $P_j$, atunci probabilitatea de a sări din $P_i$ în $P_j$ (prin navigare directă) va fi reprezentată ca un element nenul în matricea noastră. Pentru a asigura că matricea este stocastică (fiecare coloană însumează 1), se normalizează după numărul de link-uri ieșite.

  \item \textbf{Exemplu concret cu 4 pagini.} Considerăm 4 pagini web: $P_1, P_2, P_3, P_4$ și următoarea structură de link-uri:
  \[
    P_1 \to \{P_2, P_3\}, \quad
    P_2 \to \{P_3\}, \quad
    P_3 \to \{P_1, P_4\}, \quad
    P_4 \to \{P_2\}.
  \]
  Matricea de \emph{adiacență} (prin linii) ar putea arăta astfel:
  \[
    A = \begin{bmatrix}
    0 & 1 & 1 & 0 \\[0.3em]
    0 & 0 & 1 & 0 \\[0.3em]
    1 & 0 & 0 & 1 \\[0.3em]
    0 & 1 & 0 & 0
    \end{bmatrix}.
  \]
  Pentru a obține \emph{matricea de tranziție} $M$ (stocastică), fiecare coloană se normalizează la 1, iar apoi se aplică un factor de \emph{damping} (de ex. $0.85$) pentru a reflecta probabilitatea ca un utilizator să revină aleator la oricare pagină.

  \item \textbf{Rolul valorii proprii $\lambda=1$.} În matricea Google rezultată, valoarea proprie de interes este $\lambda=1$. Vectorul propriu asociat acestei valori reprezintă \emph{PageRank-ul}, adică un vector care oferă “importanța” fiecărei pagini. Pentru a-l determina, se rezolvă
  \[
    (M - I)x = 0 \quad \Longrightarrow \quad Mx = x,
  \]
  unde $x$ este vectorul propriu asociat lui $\lambda=1$. Practic, $x$ se obține prin iterații de putere directă (sau metode similare).

  \item \textbf{Deflația în PageRank.} Dacă anumite pagini sunt “izolate” sau formează sub-componente, se pot crea blocuri separate pentru care vectorul propriu asociat lui $\lambda=1$ se calculează ușor, după care aceste blocuri pot fi \emph{deflate} pentru a reduce dimensiunea problemei și, implicit, efortul de calcul.
\end{itemize}


\subsubsection{Metoda Householder}

Spre deosebire de metodele puterii (care furnizează aproximări ale valorilor și vectorilor proprii), metoda Householder urmărește explicit construirea, prin transformări ortogonale (sau unitare), a unei forme Schur pentru matricea inițială. Această abordare se poate organiza sub forma \emph{algoritmului QR}, care conține două etape:

\begin{enumerate}
	\item \textbf{Etapa directă}, de reducere a matricei date la forma Hessenberg superior prin transformări ortogonale de asemănare.
	\item \textbf{Etapa iterativă}, de construcţie recurentă a unui şir de matrici convergent către forma Schur reală. Această etapă folosește ideea factorizării $QR$ a matricei, la care se adaugă eventual \emph{deplasări} (shift-uri) pentru a accelera convergența.
\end{enumerate}

Există mai multe variante ale algoritmului QR (cu deplasare simplă, deplasare dublă etc.), însă ideea principală este aceeași: se aplică în mod repetat factorizări și transformări ortogonale, iar în final se ajunge la o matrice aproape triunghiulară, din care citim valorile proprii (pe diagonală sau în blocuri de dimensiune \(2\times 2\)).


%----------------------------------------------------------------------------------------
%       PROBLEME PROPUSE
%----------------------------------------------------------------------------------------

\section{Probleme}

\begin{questions}
        \boxedpoints
	\pointsinmargin
    \question Fie matricea tridiagonală:

\[
	A = \begin{bmatrix}
			a_1 & c_1 & \dots &        &        \\
			b_2 & a_2 & c_2   & \dots  &        \\
			\vdots & \vdots & \ddots & \ddots &        \\
			      &        & b_{n-1} & a_{n-1} & c_{n-1} \\
			      &        &        & b_n     & a_n
	\end{bmatrix}.
\]

Se construieşte şirul de polinoame:

\[
	p_0(\lambda) = 1,\quad
	p_1(\lambda) = \lambda - a_1,\quad
	p_n(\lambda) = (\lambda - a_n)\,p_{n-1}(\lambda) - b_n c_{n-1}\,p_{n-2}(\lambda).
\]

\begin{enumerate}
	\item Arătaţi că $p_{n}(\lambda)$ este polinomul caracteristic al matricei $A$.
	\item Scrieţi o funcţie OCTAVE care calculează valorile şi vectorii proprii ale matricei $A$.
\end{enumerate}

\question

Să se demonstreze pentru o matrice $A \in \mathbb{R}^{n \times n}$ proprietăţile următoare:

\begin{enumerate}
	\item $\sigma(A^{-1}) = \left\lbrace \tfrac{1}{\lambda _{1}}, \tfrac{1}{\lambda _{2}}, \ldots, \tfrac{1}{\lambda _{n}}\right\rbrace $;
	\item $\sigma(A - \mu I_{n}) = \left\lbrace \lambda_{i} - \mu \right\rbrace , \forall \mu \in \mathbb{R}$;
	\item $\sigma(A^{k}) = \left\lbrace \lambda_{i}^{k} \right\rbrace , \forall k \in \mathbb{N}$;
	\item $\sigma((A - \mu I_{n})^{- 1}) = \left\lbrace \tfrac{1}{\lambda_{i} - \mu} \right\rbrace , \forall \mu \in \mathbb{R}$.
\end{enumerate}

\question
Calculaţi valorile şi vectorii proprii ai unui reflector Householder.

\emph{Indicaţie:} $G^T u = e_1G$  - este un reflector. Coloanele lui $G$ sunt vectori proprii.

\question
Pentru matricea:
\[
	A = \begin{bmatrix}
			c & -s \\
			s & c
		\end{bmatrix}
	\in \mathbb{R}^{2 \times 2}, \quad c^2 + s^2 = 1,
\]
calculaţi valorile şi vectorii proprii.
\end{questions}
\end{document}
