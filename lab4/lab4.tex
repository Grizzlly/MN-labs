\documentclass{exam}

\usepackage{indentfirst}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{color}
\usepackage{fancyvrb}
\usepackage{amsmath}
\usepackage{algorithm}
\usepackage{algpseudocode}

\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}

\lstset{ %
	backgroundcolor=\color{white},		% choose the background color; you must add \usepackage{color} or \usepackage{xcolor}
	basicstyle=\small\ttfamily,		% the size of the fonts that are used for the code
	breakatwhitespace=false,			% sets if automatic breaks should only happen at whitespace
	breaklines=true,					% sets automatic line breaking
	captionpos=b,						% sets the caption-position to bottom
	columns=fullflexible,
	commentstyle=\color{mygreen},		% comment style
	deletekeywords={...},				% if you want to delete keywords from the given language
	escapeinside={\%*}{*)},			% if you want to add LaTeX within your code
	extendedchars=true,				% lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
	frame=single,						% adds a frame around the code
	keepspaces=true,					% keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
	keywordstyle=\color{blue},			% keyword style
	language=Octave,					% the language of the code
	morekeywords={*,...},				% if you want to add more keywords to the set
	%   numbers=left,						% where to put the line-numbers; possible values are (none, left, right)
	%   numbersep=6pt,						% how far the line-numbers are from the code
	%   numberstyle=\tiny\color{mygray},	% the style that is used for the line-numbers
	rulecolor=\color{black},			% if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
	showspaces=false,					% show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
	showstringspaces=false,			% underline spaces within strings only
	showtabs=false,					% show tabs within strings adding particular underscores
	stepnumber=1,						% the step between two line-numbers. If it's 1, each line will be numbered
	stringstyle=\color{mymauve},		% string literal style
	tabsize=2,							% sets default tabsize to 2 spaces
	title=\lstname						% show the filename of files included with \lstinputlisting; also try caption instead of title
}

% Creates a new command to include a perl script, the first parameter is the filename of the script (without .pl), the second parameter is the caption
\newcommand{\octavescript}[2]{
	\lstinputlisting[caption=#2,label=#1]{#1}
}

\newcommand{\MNLab}{Laborator\ \#4}
\newcommand{\MNLabTitle}{Eliminare gaussiană cu pivotare totală și scalare. Algoritmul Thomas pentru rezolvarea sistemului 3-diagonal.}
\newcommand{\MNLabTitleHeader}{Eliminare gaussiană}
\newcommand{\MNAuthor}{Andrei STAN, Florin Pop, Mihaela Andreea-Vasile}

\renewcommand{\contentsname}{Cuprins}
\renewcommand{\figurename}{Figura}

\setlength{\parskip}{0.5\baselineskip}

\graphicspath{{./img/}}

\title{
	\textmd{\textbf{\MNLabTitle}}
	\author{Colaboratori: \MNAuthor}
}

\pagestyle{headandfoot}

\header{Metode Numerice}
{\MNLabTitleHeader, Pagina \thepage\ din \numpages}
{2025}
\footer{Facultatea de Automatică și Calculatoare}{}{Pagina \thepage\ din \numpages}

\begin{document}

\begin{coverpages}

	\maketitle
	\tableofcontents

\end{coverpages}

\section{Obiective laborator}

\par În urma parcurgerii acestui laborator, studentul va fi capabil să:
\begin{itemize}
	\item Transforme o matrice nesingulară într-o matrice superior sau inferior triunghiulară folosind una din metodele prezentate de eliminare gaussiană;
	\item Implementeze algoritmii de eliminare gaussiană prezentați;
	\item Implementeze algoritmul Thomas.
\end{itemize}

\section{Noțiuni teoretice}

Acest laborator are ca scop familiarizarea cu metodele numerice directe de transformare a unei matrice nesingulare la forma superior triunghiular\u{a} sau inferior triunghiular\u{a}. Aceaste metode poart\u{a} numele de \textit{elimin\u{a}ri Gaussiene}. Cea mai simpl\u{a} metod\u{a} de eliminare este \textit{eliminarea gaussian\u{a} cu pivotare par\c{t}ial\u{a}}. Pentru aceast\u{a} metod\u{a} vom prezenta algoritmul GPP. Cea mai bun\u{a} metod\u{a} este \textit{eliminarea gaussian\u{a} cu pivotare total\u{a} sau complet\u{a}}, numit GPT \^{i}n cadrul acestui laborator. O tehnic\u{a} de scalare care mic\c{s}oreaz\u{a} eroarea \c{s}i elimin\u{a} anularea flotant\u{a} este \textit{pivotarea par\c{t}ial\u{a} cu pivot scalat pe coloan\u{a}} (algoritmul GPPS).

Eliminarea gaussian\u{a} este echivalent\u{a} cu metoda factoriz\u{a}rii LU care trebuie s\u{a} fie utilizat\u{a} \^{i}mpreun\u{a} cu o strategie de pivotare adecvat\u{a} (factorizarea LUP). O strategie de pivotare este necesar\u{a} \^in general deoarece este posibil ca eliminarea gaussian\u{a} s\u{a} nu poat\u{a} transforma o matrice dat\u{a} la o form\u{a} triunghiular\u{a}. Pentru o matrice simetric\u{a} \c{s}i pozitiv definit\u{a} cea mai bun\u{a} metod\u{a} de aducere la forma triunghiular\u{a} este folosirea factoriz\u{a}rii Cholesky.

Algoritmul Thomas este o form\u{a} simplificat\u{a} a elimin\u{a}rii gaussiene pentru o matrice tridiagonal\u{a}. Acest algoritm este folosit pentru rezolvarea sistemelor de ecua\c{t}ii liniare tridiagonale (des \^{i}nt\^{a}lnite \^{i}n metodele de interpolare cu func\c{t}ii spline). Complexitatea algoritmului Thomas este $O(n)$ \^{i}n timp ce elimin\u{a}rile gaussiene au complexitatea $O(n^3)$.

\subsection{Eliminarea gaussian\u{a} - G}

\par Eliminarea gaussian\u{a} este o tehnic\u{a} pentru transformarea matricei $A$ la forma superior triunghiular\u{a}. Matricea de transformare $T$ este o matrice inferior triunghiular\u{a} unitar\u{a} ob\c{t}inut\u{a} ca o secven\c{t}\u{a} (produs) de transform\u{a}ri inferior triunghiulare elementare de forma $ T = T_{n-1} T_{n-2} \ldots T_1$, unde matricele $T_p$ sunt inferior triunghiulare, de ordin $n$, de forma:
$$T_p = I_n - t_p e_p^T,$$

\noindent $e_{p}$ este coloana $p$ din matricea unitate \c{s}i
$$t_p = \begin{bmatrix}0 & \cdots & 0 & \mu_{p+1p} & \cdots & \mu_{np}\end{bmatrix}.$$

Metoda de mai sus se poate realiza dac\u{a} toate submatricele de forma $A^{[p]}=A(1:p,1:p)$ sunt nesingulare. Scalarii $\mu_{ip}$, numi\c{t}i {\em multiplicatori gaussieni}, ce asigur\u{a} satisfacerea condi\c{t}iei de anulare a elementelor din coloana $p$, de sub diagonala principal\u{a}, au expresia:
$$\mu_{ip}=a_{ip}/a_{pp},\quad i=p+1:n$$

\^{I}n efectuarea opera\c{t}iei $A\leftarrow T_pA$, se vor memora multiplicatorii gaussieni în locul zerourilor create sub diagonala principal\u{a}, primele $p-1$ coloane ale lui $A$ nu sunt afectate, iar coloanele $a_j$, $j = p+1:n$ sunt transformate astfel:
$$(T_p a_j)_i = ((I_n - t_pe_p^T)a_j)_i = (a_j - t_p a_{pj})_i = a_{ij} - \mu_{ip} a_{pj}, \quad i=p+1:n.$$

Algoritmul G de eliminare gaussian\u{a} este:

\begin{algorithm}[H]
	\caption{Eliminare gaussian\u{a}}
	\label{g}
	\begin{algorithmic}[h]
		\Procedure{G}{$A$}
		\For{$p=1:n-1$}
		\For{$i=p+1:n$}
		\State $\mu_{ip} = a_{ip}/a_{pp}$;
		\State $a_{ip} = 0$;
		\For{$j=p+1:n$}
		\State $a_{ij} = a_{ij} - \mu_{ip} a_{pj}$;
		\EndFor
		\EndFor
		\EndFor
		\State return $A$;
		\EndProcedure
	\end{algorithmic}
\end{algorithm}

\par Num\u{a}rul de opera\c{t}ii pentru algoritmul G este $O(n^3)$ (aproximativ $\frac{2n^3}{3}$ opera\c{t}ii), iar memoria folosit\u{a}, conform cu schema descris\u{a} este $O(n^2)$. Nesingularitatea submatricelor nu este o condi\c{t}ie necesar\u{a} pentru existen\c{t}a \c{s}i unicitatea solu\c{t}iei unui sistem de forma $Ax=b$, unde $A$ este adus\u{a} prin transformare la forma superior triunghiular\u{a}. Pentru a elimina aceast\u{a} condi\c{t}ie se introduc strategiile de pivotare:

\begin{itemize}
	\item Eliminarea gaussian\u{a} cu pivotare par\c{t}ial\u{a} - GPP;
	\item Eliminarea gaussian\u{a} cu pivotare par\c{t}ial\u{a} cu pivot scalat - GPPS;
	\item Eliminarea gaussian\u{a} cu pivotare total\u{a} - GPT.
\end{itemize}

\par Singularitatea submatricelor $A^{[p]}$ este echivalent\u{a} cu anularea elementului $a_{pp}$, numit pivot, la pasul $p$ al algoritmului G. Consecin\c{t}a acestei anul\u{a}ri conduce la imposibilitatea calculului multiplicatorilor gaussieni.

\par Este necesar\u{a} aducerea pe pozi\c{t}ia pivotului (linia $p$ \c{s}i coloana $p$) a unui element nenul, preferabil de modul c\^at mai mare, prin permutare de linii \c{s}i/sau coloane.

\par O matrice de permutare este o matrice care are un singur element nenul egal cu 1 pe orice linie \c{s}i pe orice coloan\u{a} a sa. Ea se ob\c{t}ine din matricea unitate prin interschimbarea (o dat\u{a} sau de mai multe ori) a dou\u{a} linii \c{s}i/sau a dou\u{a} coloane. Iat\u{a} un exemplu (interschimbarea liniilor 1 \c{s}i 2, apoi a coloanelor 2 \c{s}i 3):

\[
	P = \begin{bmatrix}
		0 & 0 & 1 \\
		1 & 0 & 0 \\
		0 & 1 & 0 \\
	\end{bmatrix}
\]

Interschimbarea a dou\u{a} linii ale unei matrice este echivalent\u{a} cu multiplicarea acelei matrice cu o matrice de permutare la st\^{a}nga. Interschimbarea a dou\u{a} coloane este echivalent\u{a} cu multiplicarea matricei cu o matrice de permutare la dreapta.

%----------------------------------------------------------------------------------------
%	PROBLEM 1
%----------------------------------------------------------------------------------------
\subsection{Eliminarea gaussian\u{a} cu pivotare parţială - GPP}

\par Pivotarea par\c{t}ial\u{a} are loc numai prin permutarea liniilor. La pasul $p$ al algoritmului G se aduce \^{\i}n pozi\c{t}ia $(p,p)$ a pivotului cel mai mare element \^{\i}n modul dintre elementele subdiagonale din coloana $p$, fie acesta $a_{i_p p}\ne 0$, prin permutarea liniilor $p$ \c{s}i $i_p$. Acest lucru este echivalent cu multiplicarea matricei $A$ la st\^{a}nga cu matricea de permutare $P_{i_p p}\stackrel{\rm not}{=}P_p$, astfel \^{\i}nc\^at pasul $p$ calculeaz\u{a} $A \leftarrow T_p P_p A$, \^{\i}ntregul algoritm fiind:
$$
	A \leftarrow U = T_{n-1} P_{n-1} T_{n-2} P_{n-2} \ldots T_1 P_1 A
$$

Algoritmul GPP de eliminare gaussian\u{a} cu pivotare par\c{t}ial\u{a} este:

\begin{algorithm} [H]
	\caption{Eliminarea gaussian\u{a} cu pivotare par\c{t}ial\u{a}}
	\label{gpp}
	\begin{algorithmic}[1]
		\Procedure{GPP}{$A$}
		\For{$p=1:n-1$}
		\State Determin\u{a} primul $i_p$ ($p \leq i_p \leq n$) a.î. $|a_{i_p p}|=\max_{i=p:n}{\{|a_{ip}|\}}$; $v(p) = i_p;$
		\State $v(p) = i_p;$
		\For{$j=p:n$}
		\State $a_{pj} \leftrightarrow a_{i_p j}$;
		\EndFor
		\For{$i=p+1:n$}
		\State $\mu_{ip} = a_{ip}/a_{pp}$;
		\State $a_{ip} = 0$;
		\For{$j=p+1:n$}
		\State $a_{ij} = a_{ij} - \mu_{ip} a_{pj}$;
		\EndFor
		\EndFor
		\EndFor
		\State return $A,v$;
		\EndProcedure
	\end{algorithmic}
\end{algorithm}

Pa\c{s}ii 8-14 reprezint\u{a} algoritmul G pentru matricea permutat\u{a}. Vectorul $v$ memoreaz\u{a} permut\u{a}rile de linii.

%----------------------------------------------------------------------------------------
%	PROBLEM 2
%----------------------------------------------------------------------------------------
\subsection{Eliminarea gaussian\u{a} cu pivotare parţială cu pivot scalat - GPPS}

\par Aceast\u{a} tehnic\u{a} este similar\u{a} cu precedenta, doar c\u{a} definim la \^{i}nceput un factor de scalare pentru fiecare linie $i$, factor de forma:
$$s_i = \max_{j=p:n}{\{|a_{ij}|\}} \quad sau \quad s_i = \sum_{j=p}^n{|a_{ij}|}$$

\par Dac\u{a} exist\u{a} un $i$ astfel \^{i}nc\^{a}t $s_i = 0$ atunci matricea este singular\u{a}. Pa\c{s}ii urm\u{a}tori vor stabili interschimb\u{a}rile care se vor face. La pasul $p$ se va g\u{a}si  \^{i}ntregul $i_p$ astfel \^{i}nc\^{a}t:
$$\frac{|a_{i_p p}|}{s_{i_p}} = \max_{i=p:n}{\frac{|a_{i p}|}{s_i}}$$

\par Scalarea ne garanteaz\u{a} c\u{a} cel mai mare element din fiecare coloana are \^{i}nainte de compara\c{t}iile necesare pentru scimbare m\u{a}rimea relativ\u{a} 1. Scalarea se realizeaz\u{a} doar \^{i}n compara\c{t}ii, nu efectiv \^{i}n matrice, astfel c\u{a} imp\u{a}r\c{t}irea cu factorul de scalare nu produce nici o eroare
de rotunjire.

Algoritmul GPPS de eliminare gaussian\u{a} cu pivotare par\c{t}ial\u{a} cu pivot scalat este:

\begin{algorithm}[H]
	\caption{Eliminarea gaussian\u{a} cu pivotare par\c{t}ial\u{a} cu pivot scalat}
	\label{gpps}
	\begin{algorithmic}[1]
		\Procedure{GPPS}{$A$}
		\For{$p=1:n-1$}
		\State Determin\u{a} $i_p$ a.î. $\frac{|a_{i_p p}|}{s_{i_p}} = \max_{i=p:n}{\frac{|a_{i p}|}{s_i}}$; $v(p) = i_p;$
		\For{$j=1:n$}
		\State $a_{pj} \leftrightarrow a_{i_p j}$;
		\EndFor
		\For{$i=p+1:n$}
		\State $\mu_{ip} = a_{ip}/a_{pp}$;
		\State $a_{ip} = 0$;
		\For{$j=p+1:n$}
		\State $a_{ij} = a_{ij} - \mu_{ip} a_{pj}$;
		\EndFor
		\EndFor
		\EndFor
		\State return $A, v$;
		\EndProcedure
	\end{algorithmic}
\end{algorithm}
Pa\c{s}ii 7-13 reprezint\u{a} algoritmul G pentru matricea permutat\u{a}. Vectorul $v$ memoreaz\u{a} permut\u{a}rile de linii. Complexitatea algoritmului GPP este aceea\c{s}i cu a lui G.


%----------------------------------------------------------------------------------------
%	PROBLEM 3
%----------------------------------------------------------------------------------------
\subsection{Eliminarea gaussian\u{a} cu pivotare total\u{a} - GPT}

\par Stabilitate numeric\u{a} mai bun\u{a} se ob\c{t}ine dac\u{a} pivotul de la
pasul $p$ se alege drept cel mai mare element \^{\i}n modul dintre
elementele $a_{ij}$, cu $i=p:n$, $j=p:n$, fie el $a_{i_p j_p}$, \c{s}i este adus \^{\i}n pozi\c{t}ia $(p,p)$ a pivotului prin permutarea liniilor $p$ \c{s}i $i_p$ \c{s}i a coloanelor $p$ \c{s}i $j_p$. Acest lucru este echivalent cu multiplicarea matricei $A$ la st\^{a}nga cu matricea de permutare $P^{st}_{i_p p}\stackrel{\rm not}{=}P^{st}_p$ \c{s}i cu multiplicarea matricei $A$ la dreapta cu matricea de permutare $P^{dr}_{j_p p}\stackrel{\rm not}{=}P^{dr}_p$. La pasul $p$ se calculeaz\u{a} $A \leftarrow T_p P^{st}_p A P^{dr}_p$, \^{\i}ntregul algoritm fiind:
$$A \leftarrow U = T_{n-1} P^{st}_{n-1} T_{n-2} P^{st}_{n-2} \ldots T_1 P^{st}_1 A P^{dr}_1 P^{dr}_2 \ldots P^{dr}_{n-1}.$$

Algoritmul GPPS de eliminare gaussian\u{a} cu pivotare  total\u{a}  este:

\begin{algorithm} [H]
	\caption{Eliminarea gaussian\u{a} cu pivotare total\u{a}}
	\label{gpt}
	\begin{algorithmic}[1]
		\Procedure{GPT}{$A$}
		\For{$p=1:n-1$}
		\State Determin\u{a} $i_p$ \c{s}i $j_p$ ($p \leq i_p, j_p \leq n$) a.i $|a_{i_p j_p}|=\max_{i=p:n, j=p:n}{\{|a_{ij}|\}}$; $v_{st}(p) = i_p$; $v_{dr}(p) = j_p$;
		\For{$j=p:n$}
		\State $a_{pj} \leftrightarrow a_{i_p j}$;
		\EndFor
		\For{$i=1:n$}
		\State $a_{ip} \leftrightarrow a_{i j_p}$;
		\EndFor
		\For{$i=p+1:n$}
		\State $\mu_{ip} = a_{ip}/a_{pp}$;
		\State $a_{ip} = 0$;
		\For{$j=p+1:n$}
		\State $a_{ij} = a_{ij} - \mu_{ip} a_{pj}$;
		\EndFor
		\EndFor
		\EndFor
		\State return $A, v_{st}, v_{dr}$;
		\EndProcedure
	\end{algorithmic}
\end{algorithm}

\par Pa\c{s}ii 10-16 reprezint\u{a} algoritmul G pentru matricea permutat\u{a}. Vectorul $v_{st}$ memoreaz\u{a} permut\u{a}rile de linii iar $v_{dr}$ memoreaz\u{a} permut\u{a}rile de coloane. Complexitatea algoritmului GPP este aceea\c{s}i cu a lui G.

%----------------------------------------------------------------------------------------
%	PROBLEM 4
%----------------------------------------------------------------------------------------
\subsection{Algoritmul Thomas pentru rezolvarea sistemului 3-diagonal}

Sistemul tridiagonal se poate scrie compact sub forma $a_i x_{i-1} + b_i x_i + c_i x_{i+1} = d_i$, $i=1:n$ cu men\c{t}iunea c\u{a} $a_1=0$ \c{s}i $c_n = 0$, iar componentele $x_0$ \c{s}i $x_{n+1}$ nu sunt definite. Forma general\u{a} este:
$$\begin{bmatrix}
		{b_1} & {c_1} & {   }  & {   }  & { 0 }     \\
		{a_2} & {b_2} & {c_2}  & {   }  & {   }     \\
		{   } & {a_3} & {b_3}  & \ddots & {   }     \\
		{   } & {   } & \ddots & \ddots & {c_{n-1}} \\
		{ 0 } & {   } & {   }  & {a_n}  & {b_n}     \\
	\end{bmatrix}
	\begin{bmatrix}
		{x_1 } \\
		{x_2 } \\
		{x_3 } \\
		\vdots \\
		{x_n } \\
	\end{bmatrix}
	=
	\begin{bmatrix}
		{d_1 } \\
		{d_2 } \\
		{d_3 } \\
		\vdots \\
		{d_n } \\
	\end{bmatrix}
$$

\par Algoritmul presupune modificarea coeficien\c{t}ilor sistemului \c{s}i aducerea lor la o form\u{a} prin care sistemul de poate rezolva direct prin substitu\c{t}ie \^{i}napoi.
$$c\rq{}_i =
	\begin{cases}
		\begin{array}{lcl}
			\cfrac{c_i}{b_i}                      &  & i = 1     \\
			\cfrac{c_i}{b_i - c\rq{}_{i - 1} a_i} &  & i = 2:n-1 \\
		\end{array}
	\end{cases}
$$

$$d\rq{}_i =
	\begin{cases}
		\begin{array}{lcl}
			\cfrac{d_i}{b_i}                                           &  & i = 1   \\
			\cfrac{d_i - d\rq{}_{i - 1} a_i}{b_i - c\rq{}_{i - 1} a_i} &  & i = 2:n \\
		\end{array}
	\end{cases}
$$

Prin formulele de mai sus s-a executat de fapt un pas al elimin\u{a}rii gaussiene. Solu\c{t}ia sistemului va fi dat\u{a} de formulele:
$$\begin{cases}
		x_n = d'_n \\
		x_i = d'_i - c'_i x_{i + 1} \quad i=n-1:1
	\end{cases}$$

\par Sistemul nu se mai p\u{a}streaz\u{a} \^{i}n memorie prin \^{i}ntrega lui matrice, ci doar prin trei vectori de valori corespunz\u{a}toare celor trei diagonale.

\par Algoritmul Thomas este utilizat deoarece este rapid \c{s}i apare frecvent \^{i}n practic\u{a}: interpol\u{a}ri, ecua\c{t}ii diferenc\c{t}iale, etc. De\c{s}i situa\c{t}ia este rar\u{a}, algoritmul poate fi instabil dac\u{a} $b_i - c\rq{}_{i-1} a_i = 0$ sau numeric zero pentru orice $i$. Aceasta se \^{i}nt\^{a}mpl\u{a} dac\u{a} matricea este singular\u{a}, dar \^{i}n cazuri rare se poate \^{i}ntampla \c{s}i pentru o matrice nesingular\u{a}. Condi\c{t}ia de stabilitate este, $\forall i$:
$$|b_i| > |a_i| + |c_i|$$

\noindent condi\c{t}ie care indic\u{a} diagonal-dominan\c{t}a matricei $A$. Dac\u{a} algoritmul este numeric instabil se pot aplica strategii de pivotare, ca \^{i}n cazul elimin\u{a}rii gaussiene.


\section{Probleme rezolvate}

\subsection{Problema 1}

Fie sistemul de ecua\c{t}ii:
$\displaystyle \begin{cases}
		5.2 \cdot x_1 + 7.1 \cdot x_2 = 19.8 \\
		2.4 \cdot x_1 + 3.2\cdot x_2 = 4.1
	\end{cases}$ Rezolva\c{t}i sistemul folosind eliminare gaussian\u{a} cu pivotare par\c{t}ial\u{a}.

\textit{Soluţie:}

Valoarea maxim\u{a} a coeficien\c{t}ilor de pe prima coloan\u{a} este 5.2 (coeficientul de pe prima linie). A\c{s}adar, nu schimb\u{a}m ordinea ecua\c{t}iilor.\\

$\mu_{21} = \frac{2.4}{5.2} = 0.46154$\\

Sistemul ini\c{t}ial este echivalent cu:
$\displaystyle
	\begin{cases} 5.2 \cdot x_1 + 7.1 \cdot x_2 = 19.8 \\
		-0.07692 \cdot x_2 = -5.0385
	\end{cases}$\\

În final, ob\c{t}inem solu\c{t}ia:
$\displaystyle \begin{cases} x_1 = -85.625 \\ x_2 = 65.5\end{cases}$\\

%\end{Problem}


\subsection{Problema 2}
Să se scrie un program OCTAVE pentru a implementa algoritmul de eliminarea gaussian\u{a}.

\textit{Soluţie:}

\octavescript{./src/G.m}{}
%\end{Problem}

\subsection{Problema 3}
Să se scrie un program OCTAVE pentru a implementa algoritmul de eliminarea gaussian\u{a} cu pivotare par\c{t}ial\u{a}.

\textit{Soluţie:}

\octavescript{./src/GPP.m}{}
%\end{Problem}

\subsection{Problema 4}
Să se scrie un program OCTAVE pentru a implementa algoritmul de eliminarea gaussian\u{a} cu pivotare total\u{a}.

\textit{Soluţie:}

\octavescript{./src/GPT.m}{}
%\end{Problem}


\subsection{Problema 5}
Să se scrie un program OCTAVE pentru a implementa algoritmul Thomas de rezolvare a unui sistem 3-diagonal.

\textit{Soluţie:}

\octavescript{./src/Thomas.m}{}


\begin{center}
	\begin{tabular}{| l | l |}
		\hline
		\\
		\textbf{Date de intrare:} \\\\
		$a = $
		$\begin{bmatrix}
				 2 \quad
				 9\quad
				 2 \quad
				 3 \quad
				 6
			 \end{bmatrix}$,

		$b = $
		$\begin{bmatrix}
				 12 \quad
				 15\quad
				 2 \quad
				 9 \quad
				 1 \quad
				 0
			 \end{bmatrix}$,

		$c = $
		$\begin{bmatrix}
				 10 \quad
				 3\quad
				 9 \quad
				 1 \quad
				 4
			 \end{bmatrix}$,

		$d = $
		$\begin{bmatrix}
				 1 \quad
				 5\quad
				 9 \quad
				 11 \quad
				 13 \quad
				 7
			 \end{bmatrix}$

		\\ \\
		\hline
		\\
		\textbf{Date de ieşire:}  \\ \\
		$ x = $
		$\begin{bmatrix}
				 0.160494 \quad
				 -0.092593 \quad
				 2.022634  \quad
				 0.643118  \quad
				 1.166667 \quad
				 2.475995
			 \end{bmatrix}
		$
		\\
		\hline
	\end{tabular}
\end{center}

%\end{Problem}

\section{Probleme}

%----------------------------------------------------------------------------------------
%	PROBLEM 1
%----------------------------------------------------------------------------------------
\subsection{Problema 1}
Implementa\c{t}i \^{i}n OCTAVE algoritmul GPPS.
%\end{Problem}

%----------------------------------------------------------------------------------------
%	PROBLEM 2
%----------------------------------------------------------------------------------------
\subsection{Problema 2}
Modifica\c{t}i algoritmii GPP \c{s}i GPT pentru a lucra cu o matrice superior Hessemberg. Implementa\c{t}i H\_GPP \c{s}i H\_GPT.
%\end{Problem}

%----------------------------------------------------------------------------------------
%	PROBLEM 3
%----------------------------------------------------------------------------------------
\subsection{Problema 3}
Construi\c{t}i o variant\u{a} modificat\u{a} pentru algoritmul lui Thomas care s\u{a} lucreze cu matricea:
\[
	A = \begin{bmatrix}
		{b_1} & { 0 }  & {c_1}      & {   }      & {   }     & {   }     & { 0 }     \\
		{ 0 } & {b_2}  & { 0 }      & {c_2}      & {   }     & {   }     & {   }     \\
		{a_3} & { 0 }  & {b_3}      & { 0 }      & {c_3}     & {   }     & {   }     \\
		{   } & \ddots & \ddots     & \ddots     & \ddots    & \ddots    & {   }     \\
		{   } & {   }  & { a_{n-2}} & { 0 }      & {b_{n-2}} & { 0 }     & {c_{n-2}} \\
		{   } & {   }  & {   }      & { a_{n-1}} & { 0 }     & {b_{n-1}} & { 0 }     \\
		{ 0 } & {   }  & {   }      & {   }      & {a_n}     & { 0 }     & {b_n}     \\
	\end{bmatrix}
\]

Scrie\c{t}i o func\c{t}ie OCTAVE cu semn\u{a}tura \verb|function x = solve(a,b,c,d)| care s\u{a} rezolv\u{a} sistemul de ecua\c{t}ii $Ax = d$.
%\end{Problem}


\subsection{Problema 4}
Fie sistemul de ecua\c{t}ii:
$\displaystyle
	\begin{cases} 1.5 \cdot x_1 - 2.1 \cdot x_2 = 8.3 \\
		-7.6 \cdot x_1 + 3.11 \cdot x_2 = 6.7
	\end{cases}$
Rezolva\c{t}i sistemul folosind eliminare GPP, GPPS, GPT.

%\end{Problem}

%----------------------------------------------------------------------------------------

\end{document}
